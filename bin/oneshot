#!/usr/bin/env bash
# One-shot change: commit staged changes to a new branch and create MR
# Compatible with bash and zsh
#
# Usage:
#   oneshot                              Interactive ticket selection (or create new)
#   oneshot PROJ-1234                    Use existing ticket
#   oneshot https://slack.com/...        Create ticket + link to Slack thread
#   oneshot --dry-run                    Show what would be done
#   oneshot --base origin/main           Explicitly set base branch (default: origin/main)
#
# Workflow:
#   1. Check for staged changes
#   2. Select existing Jira ticket OR create new ticket interactively
#   3. Create new branch named after the ticket
#      - If on main: branches from origin/main
#      - If on feature branch: prompts to branch from current or origin/main
#      - Can override with --base flag
#   4. Commit staged changes with "TICKET: summary" as message
#      - Supports multiple commits interactively
#      - Re-runs pre-push checks before publishing
#   5. Run publish-changes to create MR
#   6. (If Slack URL) Post ticket link back to thread
#
# Resumability:
#   - State is saved after ticket creation
#   - If script fails (e.g., pre-push checks fail), run 'oneshot' again to resume
#   - You can add more commits and continue from where you left off

set -e

# Load shell compatibility layer
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
source "$SCRIPT_DIR/../lib/shell-compat.sh"

# Load environment variables
if [ -f "$SCRIPT_DIR/../.env" ]; then
    set -a  # automatically export all variables
    source "$SCRIPT_DIR/../.env"
    set +a
fi

# Configuration
JIRA_DOMAIN="${JIRA_DOMAIN}"
JIRA_PROJECT="${JIRA_PROJECT}"
CACHE_DIR="$HOME/.cache/jira-fzf"
STATE_DIR="$HOME/.cache/oneshot-state"

# Validate required environment variables
if [ -z "$JIRA_DOMAIN" ] || [ -z "$JIRA_PROJECT" ]; then
    echo "Error: JIRA_DOMAIN and JIRA_PROJECT must be set in .env or environment" >&2
    exit 1
fi
TICKETS_CACHE="$CACHE_DIR/tickets.json"
mkdir -p "$STATE_DIR"
DRY_RUN=false
BASE_BRANCH="origin/main"
SLACK_URL=""
SLACK_CHANNEL=""
SLACK_THREAD_TS=""

# Colors
RED='\033[38;5;167m'
GREEN='\033[38;5;114m'
YELLOW='\033[38;5;221m'
BLUE='\033[38;5;81m'
PURPLE='\033[38;5;141m'
CYAN='\033[38;5;109m'
DIM='\033[2m'
RESET='\033[0m'

# Parse arguments
TICKET_KEY=""
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --dry-run|-n)
            DRY_RUN=true
            shift
            ;;
        --base|-b)
            BASE_BRANCH="$2"
            shift 2
            ;;
        --help|-h)
            head -20 "$0" | tail -19
            exit 0
            ;;
        *)
            # Check if it's a Slack URL
            if [[ "$1" =~ ^https://.*slack\.com/archives/([A-Z0-9]+)/p([0-9]+) ]]; then
                SLACK_URL="$1"
                SLACK_CHANNEL=$(shell_get_match 1)
                # Convert p1234567890123456 to 1234567890.123456 format
                raw_ts=$(shell_get_match 2)
                SLACK_THREAD_TS="${raw_ts:0:10}.${raw_ts:10}"
            # Check if it looks like a Jira ticket
            elif [[ "$1" =~ ^${JIRA_PROJECT}-[0-9]+$ ]]; then
                TICKET_KEY="$1"
            elif [[ "$1" =~ ^[0-9]+$ ]]; then
                # Just a number - prefix with project
                TICKET_KEY="${JIRA_PROJECT}-$1"
            else
                echo -e "${RED}Unknown argument: $1${RESET}" >&2
                exit 1
            fi
            shift
            ;;
    esac
done

# Find fzf
if [ -x "$HOME/.zsh/fzf/bin/fzf" ]; then
    FZF="$HOME/.zsh/fzf/bin/fzf"
elif command -v fzf &> /dev/null; then
    FZF="fzf"
else
    echo -e "${RED}Error: fzf not found${RESET}" >&2
    exit 1
fi

export FZF_DEFAULT_OPTS="${FZF_DEFAULT_OPTS} --bind 'ctrl-d:half-page-down,ctrl-u:half-page-up'"

# Ensure we're in a git repo
if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo -e "${RED}Error: Not in a git repository${RESET}" >&2
    exit 1
fi

# ============================================================================
# Functions
# ============================================================================

# Call Jira API
jira_api() {
    local endpoint="$1"
    curl -s -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
        "https://${JIRA_DOMAIN}/rest/api/3/${endpoint}" \
        -H "Content-Type: application/json"
}

# Call Jira API with POST
jira_api_post() {
    local endpoint="$1"
    local data="$2"
    curl -s -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
        -X POST \
        "https://${JIRA_DOMAIN}/rest/api/3/${endpoint}" \
        -H "Content-Type: application/json" \
        -d "$data"
}

# Get ticket summary from Jira
get_ticket_summary() {
    local key="$1"
    if [ -z "$JIRA_EMAIL" ] || [ -z "$JIRA_API_TOKEN" ]; then
        return 1
    fi
    jira_api "issue/${key}?fields=summary" 2>/dev/null | \
        jq -r '.fields.summary // empty' 2>/dev/null
}

# Get current user's account ID
get_current_user_id() {
    if [ -z "$JIRA_EMAIL" ] || [ -z "$JIRA_API_TOKEN" ]; then
        return 1
    fi
    jira_api "myself" 2>/dev/null | jq -r '.accountId // empty' 2>/dev/null
}

# Get cached tickets for fzf selection
get_cached_tickets() {
    if [ -f "$TICKETS_CACHE" ]; then
        jq -r '.issues[] | .key + "\t" + .fields.summary' "$TICKETS_CACHE" 2>/dev/null
    fi
}

# Run pre-push checks
run_prepush_checks() {
    local repo_dir="$1"
    
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“${RESET}" >&2
    echo -e "${CYAN}â”ƒ${RESET} ${BLUE}Pre-push validation:${RESET} Running checks                     ${CYAN}â”ƒ${RESET}" >&2
    echo -e "${CYAN}â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›${RESET}" >&2
    echo "" >&2
    
    # Save current directory
    local original_dir=$(pwd)
    cd "$repo_dir" || return 1
    
    # Stash unstaged changes so we only validate what's staged
    local stashed=false
    if ! git diff-files --quiet; then
        echo -e "  ${DIM}Stashing unstaged changes...${RESET}" >&2
        git stash push --keep-index --quiet -m "oneshot: temporary stash for pre-push validation"
        stashed=true
    fi
    
    # Get git hooks path (could be custom via core.hooksPath)
    local hooks_path=$(git config core.hooksPath || echo ".git/hooks")
    local pre_push_hook="${hooks_path}/pre-push"
    
    local result=0
    
    # If pre-push hook exists and is executable, run it
    if [ -x "$pre_push_hook" ]; then
        echo -e "  ${DIM}Running pre-push hook...${RESET}" >&2
        
        # Pre-push hooks read from stdin: <local ref> <local sha> <remote ref> <remote sha>
        # Provide dummy data so it thinks there are commits to check
        local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD")
        local current_sha=$(git rev-parse HEAD 2>/dev/null || echo "0000000000000000000000000000000000000000")
        
        # Run hook and capture exit code
        # Skip protected branch check since we're creating a new branch anyway
        local exit_code=0
        echo "refs/heads/${current_branch} ${current_sha} refs/heads/main 0000000000000000000000000000000000000000" | SKIP_PROTECTED_BRANCH_CHECK=true "$pre_push_hook" 2>&1 >&2
        exit_code=$(shell_get_pipe_status 1)
        
        if [ $exit_code -eq 0 ]; then
            echo -e "  ${GREEN}âœ“${RESET} Pre-push hook passed" >&2
            result=0
        else
            echo -e "  ${RED}âœ— Pre-push hook failed${RESET}" >&2
            result=1
        fi
    else
        # No pre-push hook found, skip validation
        echo -e "  ${YELLOW}âš  No pre-push hook found, skipping validation${RESET}" >&2
        echo -e "  ${DIM}Hook path checked: ${pre_push_hook}${RESET}" >&2
    fi
    
    # Restore unstaged changes
    if [ "$stashed" = true ]; then
        echo -e "  ${DIM}Restoring unstaged changes...${RESET}" >&2
        git stash pop --quiet
    fi
    
    cd "$original_dir"
    echo "" >&2
    return $result
}

# Verify Slack bot has access to channel
verify_slack_channel_access() {
    local channel="$1"
    
    if [ -z "$TICKET_CREATOR_BOT_TOKEN" ]; then
        return 0  # Skip if no token
    fi
    
    echo -e "  ${DIM}Verifying bot channel access...${RESET}" >&2
    
    # Try conversations.info - if we get not_in_channel error, we know for sure bot isn't there
    local response
    response=$(curl -s -G "https://slack.com/api/conversations.info" \
        -H "Authorization: Bearer ${TICKET_CREATOR_BOT_TOKEN}" \
        --data-urlencode "channel=${channel}")
    
    if echo "$response" | jq -e '.ok == true' >/dev/null 2>&1; then
        # API call succeeded, but check if bot is actually a member
        local is_member=$(echo "$response" | jq -r '.channel.is_member // false')
        if [ "$is_member" = "true" ]; then
            echo -e "  ${GREEN}âœ“${RESET} Bot has channel access" >&2
            return 0
        else
            echo -e "  ${RED}âœ— Bot is not a member of the channel${RESET}" >&2
            echo -e "  ${DIM}Add the bot to the channel with: /invite -> \"Add apps to this channel\"${RESET}" >&2
            return 1
        fi
    else
        local error=$(echo "$response" | jq -r '.error // "unknown error"')
        
        # Only fail on definitive "not in channel" errors
        case "$error" in
            not_in_channel|channel_not_found)
                echo -e "  ${RED}âœ— Bot cannot access channel: ${error}${RESET}" >&2
                echo -e "  ${DIM}Add the bot to the channel with: /invite -> \"Add apps to this channel\"${RESET}" >&2
                return 1
                ;;
            missing_scope)
                # Bot token lacks scope to check membership, but that doesn't mean it can't post
                echo -e "  ${YELLOW}âš  Cannot verify channel access (missing scope), continuing anyway${RESET}" >&2
                echo -e "  ${DIM}If posting fails later, add the bot with: /invite -> \"Add apps to this channel\"${RESET}" >&2
                return 0
                ;;
            invalid_auth|token_revoked|account_inactive)
                echo -e "  ${RED}âœ— Bot token error: ${error}${RESET}" >&2
                echo -e "  ${DIM}Check TICKET_CREATOR_BOT_TOKEN${RESET}" >&2
                return 1
                ;;
            *)
                # Unknown error - warn but don't block
                echo -e "  ${YELLOW}âš  Could not verify channel access: ${error}${RESET}" >&2
                echo -e "  ${DIM}Continuing anyway${RESET}" >&2
                return 0
                ;;
        esac
    fi
}

# Post message to Slack thread
post_to_slack() {
    local channel="$1"
    local thread_ts="$2"
    local message_type="$3"  # "ticket" or "mr"
    local url="$4"
    local title="$5"
    
    if [ -z "$TICKET_CREATOR_BOT_TOKEN" ]; then
        echo -e "  ${YELLOW}âš  TICKET_CREATOR_BOT_TOKEN not set, skipping Slack post${RESET}" >&2
        return 1
    fi
    
    local text
    case "$message_type" in
        ticket)
            text=$':jira: A ticket was created referencing this thread: '"<${url}|${title}>"
            ;;
        mr)
            local mr_num=$(echo "$url" | grep -oE '[0-9]+$')
            text=$':gitlab: MR: <'"${url}|!${mr_num}"$'> :shipit:'
            ;;
        *)
            text="$url"
            ;;
    esac
    
    local response
    response=$(curl -s -X POST "https://slack.com/api/chat.postMessage" \
        -H "Authorization: Bearer ${TICKET_CREATOR_BOT_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "$(jq -n \
            --arg channel "$channel" \
            --arg thread_ts "$thread_ts" \
            --arg text "$text" \
            '{channel: $channel, thread_ts: $thread_ts, text: $text, unfurl_links: true, mrkdwn: true}')")
    
    if echo "$response" | jq -e '.ok == true' >/dev/null 2>&1; then
        return 0
    else
        local error=$(echo "$response" | jq -r '.error // "unknown error"')
        echo -e "  ${RED}âœ— Slack API error: ${error}${RESET}" >&2
        return 1
    fi
}

# Save state for resumption
save_state() {
    local ticket_key="$1"
    local summary="$2"
    local branch_name="$3"
    local base_branch="$4"
    local slack_url="$5"
    local slack_channel="$6"
    local slack_thread_ts="$7"
    
    local repo_root=$(git rev-parse --show-toplevel)
    local state_file="${STATE_DIR}/$(echo "$repo_root" | sed 's|/|_|g').json"
    
    jq -n \
        --arg ticket_key "$ticket_key" \
        --arg summary "$summary" \
        --arg branch_name "$branch_name" \
        --arg base_branch "$base_branch" \
        --arg slack_url "$slack_url" \
        --arg slack_channel "$slack_channel" \
        --arg slack_thread_ts "$slack_thread_ts" \
        '{
            ticket_key: $ticket_key,
            summary: $summary,
            branch_name: $branch_name,
            base_branch: $base_branch,
            slack_url: $slack_url,
            slack_channel: $slack_channel,
            slack_thread_ts: $slack_thread_ts,
            timestamp: now | todate
        }' > "$state_file"
}

# Load state for resumption
load_state() {
    local repo_root=$(git rev-parse --show-toplevel)
    local state_file="${STATE_DIR}/$(echo "$repo_root" | sed 's|/|_|g').json"
    
    if [ -f "$state_file" ]; then
        cat "$state_file"
    fi
}

# Clear saved state
clear_state() {
    local repo_root=$(git rev-parse --show-toplevel)
    local state_file="${STATE_DIR}/$(echo "$repo_root" | sed 's|/|_|g').json"
    
    rm -f "$state_file"
}

# Select ticket interactively (or create new)
select_ticket_or_slack() {
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“${RESET}" >&2
    echo -e "${CYAN}â”ƒ${RESET} ${BLUE}Select ticket${RESET} or create new                            ${CYAN}â”ƒ${RESET}" >&2
    echo -e "${CYAN}â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›${RESET}" >&2
    
    local selection
    selection=$( { echo -e "NEW\tâœ¨ Create new ticket"; get_cached_tickets; } | $FZF \
        --prompt="  ðŸŽ« Ticket > " \
        --height=20 \
        --reverse \
        --border=rounded \
        --delimiter='\t' \
        --with-nth=1,2 \
        --preview='key=$(echo {} | cut -f1); if [ "$key" = "NEW" ]; then echo "Create a new Jira ticket"; else curl -s -u "'"${JIRA_EMAIL}:${JIRA_API_TOKEN}"'" "https://'"${JIRA_DOMAIN}"'/rest/api/3/issue/${key}?fields=summary,status,assignee" 2>/dev/null | jq -r "\"Status: \" + .fields.status.name + \"\nAssignee: \" + (.fields.assignee.displayName // \"Unassigned\") + \"\n\n\" + .fields.summary" 2>/dev/null || echo "Loading..."; fi' \
        --preview-window=right:40%:wrap \
        --header="Enter: select â”‚ Paste Slack URL to link thread" \
        --print-query)
    
    # Check what user entered
    local query=$(echo "$selection" | head -1)
    local selected=$(echo "$selection" | tail -1)
    
    # Check if it's a Slack URL
    if [[ "$query" =~ ^https://.*slack\.com/archives/([A-Z0-9]+)/p([0-9]+) ]]; then
        echo "SLACK:$query"
        return 0
    fi
    
    # Check if user selected "Create new ticket"
    if [[ "$selected" =~ ^NEW ]]; then
        echo "NEW"
        return 0
    fi
    
    if [ -n "$selected" ]; then
        echo "$selected" | cut -f1
    elif [[ "$query" =~ ^${JIRA_PROJECT}-[0-9]+$ ]]; then
        echo "$query"
    elif [[ "$query" =~ ^[0-9]+$ ]]; then
        echo "${JIRA_PROJECT}-$query"
    else
        echo ""
    fi
}

# ============================================================================
# Main flow
# ============================================================================

echo "" >&2
echo -e "${PURPLE}=== One-Shot Change ===${RESET}" >&2
if [ "$DRY_RUN" = true ]; then
    echo -e "${YELLOW}[DRY RUN]${RESET}" >&2
fi
echo "" >&2

# Check for resumable state
saved_state=$(load_state)
if [ -n "$saved_state" ]; then
    saved_ticket=$(echo "$saved_state" | jq -r '.ticket_key')
    saved_branch=$(echo "$saved_state" | jq -r '.branch_name')
    saved_summary=$(echo "$saved_state" | jq -r '.summary')
    saved_timestamp=$(echo "$saved_state" | jq -r '.timestamp')
    
    echo -e "${YELLOW}âš  Found incomplete oneshot from ${saved_timestamp}${RESET}" >&2
    echo -e "  ${CYAN}Ticket:${RESET} ${saved_ticket}" >&2
    echo -e "  ${CYAN}Branch:${RESET} ${saved_branch}" >&2
    if [ -n "$saved_summary" ]; then
        echo -e "  ${CYAN}Summary:${RESET} ${DIM}${saved_summary}${RESET}" >&2
    fi
    echo "" >&2
    echo -e "  ${CYAN}Resume from saved state?${RESET} ${DIM}(y/n)${RESET}" >&2
    shell_read_prompt "  > " resume_response "-k 1"
    echo "" >&2
    echo "" >&2
    
    if [[ $resume_response =~ ^[Yy]$ ]]; then
        # Load state variables
        TICKET_KEY="$saved_ticket"
        summary="$saved_summary"
        branch_name="$saved_branch"
        BASE_BRANCH=$(echo "$saved_state" | jq -r '.base_branch')
        SLACK_URL=$(echo "$saved_state" | jq -r '.slack_url // empty')
        SLACK_CHANNEL=$(echo "$saved_state" | jq -r '.slack_channel // empty')
        SLACK_THREAD_TS=$(echo "$saved_state" | jq -r '.slack_thread_ts // empty')
        
        # Set commit_message for Slack post
        if [ -n "$summary" ]; then
            commit_message="$TICKET_KEY: $summary"
        else
            commit_message="$TICKET_KEY"
        fi
        
        # Skip to Step 3
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“${RESET}" >&2
        echo -e "${CYAN}â”ƒ${RESET} ${BLUE}Resuming:${RESET} On branch ${branch_name}                        ${CYAN}â”ƒ${RESET}" >&2
        echo -e "${CYAN}â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›${RESET}" >&2
        echo "" >&2
        
        # Verify we're on the correct branch
        current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ "$current_branch" != "$branch_name" ]; then
            echo -e "  ${YELLOW}âš  Currently on ${current_branch}, switching to ${branch_name}${RESET}" >&2
            if [ "$DRY_RUN" != true ]; then
                if ! git checkout "$branch_name" 2>&1 | while read -r line; do echo -e "    ${DIM}${line}${RESET}" >&2; done; then
                    echo -e "  ${RED}âœ— Failed to checkout branch${RESET}" >&2
                    exit 1
                fi
            fi
        fi
        
        # Jump to commit loop (skip steps 1-2)
        SKIP_TO_COMMIT_LOOP
    else
        clear_state
        echo -e "  ${DIM}Cleared saved state, starting fresh${RESET}" >&2
        echo "" >&2
    fi
fi

# Step 1: Check for staged changes
if [ "${SKIP_TO_COMMIT_LOOP:-false}" != true ]; then
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“${RESET}" >&2
    echo -e "${CYAN}â”ƒ${RESET} ${BLUE}Step 1/4:${RESET} Checking staged changes                       ${CYAN}â”ƒ${RESET}" >&2
    echo -e "${CYAN}â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›${RESET}" >&2

    staged_files=$(git diff --cached --name-only)
    staged_count=$(echo "$staged_files" | grep -c . || true)

    if [ "$staged_count" -eq 0 ]; then
        echo -e "  ${RED}âœ— No staged changes${RESET}" >&2
        echo -e "  ${DIM}Stage changes first: git add <files>${RESET}" >&2
        exit 1
    fi

    echo -e "  ${GREEN}âœ“${RESET} ${staged_count} file(s) staged:" >&2
    echo "$staged_files" | head -5 | while read -r file; do
        echo -e "    ${DIM}${file}${RESET}" >&2
    done
    if [ "$staged_count" -gt 5 ]; then
        echo -e "    ${DIM}... and $((staged_count - 5)) more${RESET}" >&2
    fi
    echo "" >&2

    # Step 1.5: Run pre-push checks
    if [ "$DRY_RUN" != true ]; then
        # Determine repository root
        repo_root=$(git rev-parse --show-toplevel)
        
        if ! run_prepush_checks "$repo_root"; then
            exit 1
        fi
    fi
fi

# Step 2: Select ticket or handle Slack URL
if [ "${SKIP_TO_COMMIT_LOOP:-false}" != true ]; then
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“${RESET}" >&2
echo -e "${CYAN}â”ƒ${RESET} ${BLUE}Step 2/4:${RESET} Select Jira ticket                            ${CYAN}â”ƒ${RESET}" >&2
echo -e "${CYAN}â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›${RESET}" >&2

# Handle Slack URL from argument
if [ -n "$SLACK_URL" ]; then
    echo -e "  ${CYAN}Slack thread:${RESET} ${DIM}${SLACK_URL}${RESET}" >&2
    
    # Verify bot can post to the channel
    if [ "$DRY_RUN" != true ] && [ -n "$TICKET_CREATOR_BOT_TOKEN" ]; then
        if ! verify_slack_channel_access "$SLACK_CHANNEL"; then
            exit 1
        fi
    fi
    
    echo "" >&2
    
    # Build flags for create-jira-ticket
    flags=()
    if [ "$DRY_RUN" = true ]; then
        flags+=(--dry-run)
    fi
    
    if [ -n "$SLACK_URL" ]; then
        flags+=(--slack-url "$SLACK_URL")
    fi
    
    # Call the shared create-jira-ticket script
    # Use temp file to capture JSON output
    result_file=$(mktemp)
    trap "rm -f '$result_file'" EXIT
    
    if ! "$SCRIPT_DIR/create-jira-ticket" "${flags[@]}" --output-file "$result_file"; then
        echo -e "  ${RED}âœ— Failed to create ticket${RESET}" >&2
        rm -f "$result_file"
        exit 1
    fi
    echo "" >&2
    echo -e "  ${DIM}Processing ticket information...${RESET}" >&2
    TICKET_KEY=$(jq -r '.key' < "$result_file")
    summary=$(jq -r '.summary' < "$result_file")
    rm -f "$result_file"
    
    if [ -z "$TICKET_KEY" ] || ! [[ "$TICKET_KEY" =~ ^${JIRA_PROJECT}-[0-9]+$ ]]; then
        echo -e "  ${RED}âœ— Failed to create ticket${RESET}" >&2
        exit 1
    fi
    
    # Post to Slack if we have a thread
    if [ -n "$SLACK_URL" ] && [ "$DRY_RUN" != true ]; then
        echo -e "  ${DIM}Posting to Slack thread...${RESET}" >&2
        
        jira_url="https://${JIRA_DOMAIN}/browse/${TICKET_KEY}"
        if post_to_slack "$SLACK_CHANNEL" "$SLACK_THREAD_TS" "ticket" "$jira_url" "${TICKET_KEY}: ${summary}"; then
            echo -e "  ${GREEN}âœ“${RESET} Posted ticket link to Slack" >&2
        fi
    fi

# Handle ticket from argument
elif [ -n "$TICKET_KEY" ]; then
    TICKET_KEY=$(echo "$TICKET_KEY" | tr '[:lower:]' '[:upper:]')
    summary=$(get_ticket_summary "$TICKET_KEY")
    if [ -n "$summary" ]; then
        echo -e "  ${GREEN}âœ“${RESET} Ticket: ${CYAN}${TICKET_KEY}${RESET}" >&2
        echo -e "    ${DIM}${summary}${RESET}" >&2
    else
        echo -e "  ${GREEN}âœ“${RESET} Ticket: ${CYAN}${TICKET_KEY}${RESET}" >&2
        echo -e "    ${YELLOW}âš  Could not fetch summary${RESET}" >&2
    fi

# Interactive selection
else
    selection=$(select_ticket_or_slack)
    
    # Check if user wants to create a new ticket
    if [ "$selection" = "NEW" ]; then
        echo -e "  ${CYAN}Creating new ticket${RESET}" >&2
        echo "" >&2
        
        # Build flags for create-jira-ticket
        flags=()
        if [ "$DRY_RUN" = true ]; then
            flags+=(--dry-run)
        fi
        
        # Call the shared create-jira-ticket script
        # Use temp file to capture JSON output
        result_file=$(mktemp)
        trap "rm -f '$result_file'" EXIT
        
        if ! "$SCRIPT_DIR/create-jira-ticket" "${flags[@]}" --output-file "$result_file"; then
            echo -e "  ${RED}âœ— Failed to create ticket${RESET}" >&2
            rm -f "$result_file"
            exit 1
        fi
        echo "" >&2
        echo -e "  ${DIM}Processing ticket information...${RESET}" >&2
        TICKET_KEY=$(jq -r '.key' < "$result_file")
        summary=$(jq -r '.summary' < "$result_file")
        rm -f "$result_file"
        
        if [ -z "$TICKET_KEY" ] || ! [[ "$TICKET_KEY" =~ ^${JIRA_PROJECT}-[0-9]+$ ]]; then
            echo -e "  ${RED}âœ— Failed to create ticket${RESET}" >&2
            exit 1
        fi
    # Check if user entered a Slack URL
    elif [[ "$selection" =~ ^SLACK:(.+)$ ]]; then
        SLACK_URL=$(shell_get_match 1)
        
        # Parse Slack URL
        if [[ "$SLACK_URL" =~ ^https://.*slack\.com/archives/([A-Z0-9]+)/p([0-9]+) ]]; then
            SLACK_CHANNEL=$(shell_get_match 1)
            raw_ts=$(shell_get_match 2)
            SLACK_THREAD_TS="${raw_ts:0:10}.${raw_ts:10}"
        fi
        
        echo "" >&2
        echo -e "  ${CYAN}Slack thread:${RESET} ${DIM}${SLACK_URL}${RESET}" >&2
        
        # Verify bot can post to the channel
        if [ "$DRY_RUN" != true ] && [ -n "$TICKET_CREATOR_BOT_TOKEN" ]; then
            if ! verify_slack_channel_access "$SLACK_CHANNEL"; then
                exit 1
            fi
        fi
        
        echo "" >&2
        
        # Build flags for create-jira-ticket
        flags=()
        if [ "$DRY_RUN" = true ]; then
            flags+=(--dry-run)
        fi
        
        # Call the shared create-jira-ticket script with Slack URL
        # Use temp file to capture JSON output
        result_file=$(mktemp)
        trap "rm -f '$result_file'" EXIT
        
        if ! "$SCRIPT_DIR/create-jira-ticket" "${flags[@]}" --slack-url "$SLACK_URL" --output-file "$result_file"; then
            echo -e "  ${RED}âœ— Failed to create ticket${RESET}" >&2
            rm -f "$result_file"
            exit 1
        fi
        echo "" >&2
        echo -e "  ${DIM}Processing ticket information...${RESET}" >&2
        TICKET_KEY=$(jq -r '.key' < "$result_file")
        summary=$(jq -r '.summary' < "$result_file")
        rm -f "$result_file"
        
        if [ -z "$TICKET_KEY" ] || ! [[ "$TICKET_KEY" =~ ^${JIRA_PROJECT}-[0-9]+$ ]]; then
            echo -e "  ${RED}âœ— Failed to create ticket${RESET}" >&2
            exit 1
        fi
        
        # Post to Slack
        if [ "$DRY_RUN" != true ]; then
            echo -e "  ${DIM}Posting to Slack thread...${RESET}" >&2
            
            jira_url="https://${JIRA_DOMAIN}/browse/${TICKET_KEY}"
            if post_to_slack "$SLACK_CHANNEL" "$SLACK_THREAD_TS" "ticket" "$jira_url" "${TICKET_KEY}: ${summary}"; then
                echo -e "  ${GREEN}âœ“${RESET} Posted ticket link to Slack" >&2
            fi
        fi
    else
        TICKET_KEY="$selection"
        
        if [ -z "$TICKET_KEY" ]; then
            echo -e "  ${RED}âœ— No ticket selected${RESET}" >&2
            exit 1
        fi
        
        # Normalize ticket key to uppercase
        TICKET_KEY=$(echo "$TICKET_KEY" | tr '[:lower:]' '[:upper:]')
        
        # Get ticket summary
        summary=$(get_ticket_summary "$TICKET_KEY")
        if [ -n "$summary" ]; then
            echo -e "  ${GREEN}âœ“${RESET} Ticket: ${CYAN}${TICKET_KEY}${RESET}" >&2
            echo -e "    ${DIM}${summary}${RESET}" >&2
        else
            echo -e "  ${GREEN}âœ“${RESET} Ticket: ${CYAN}${TICKET_KEY}${RESET}" >&2
            echo -e "    ${YELLOW}âš  Could not fetch summary${RESET}" >&2
        fi
    fi
fi

    echo "" >&2
    
    # Save state after ticket is created successfully
    if [ "$DRY_RUN" != true ]; then
        save_state "$TICKET_KEY" "$summary" "$TICKET_KEY" "$BASE_BRANCH" "$SLACK_URL" "$SLACK_CHANNEL" "$SLACK_THREAD_TS"
        echo -e "  ${DIM}Saved progress (resumable if script fails)${RESET}" >&2
    fi
fi  # End of SKIP_TO_COMMIT_LOOP check

echo "" >&2

# Step 3: Create branch and commit
if [ "${SKIP_TO_COMMIT_LOOP:-false}" != true ]; then
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“${RESET}" >&2
    echo -e "${CYAN}â”ƒ${RESET} ${BLUE}Step 3/4:${RESET} Create branch and commit                      ${CYAN}â”ƒ${RESET}" >&2
    echo -e "${CYAN}â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›${RESET}" >&2

    # Check if user is on a non-main branch and if BASE_BRANCH wasn't explicitly set
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ "$BASE_BRANCH" = "origin/main" ] && [ "$current_branch" != "main" ] && [ "$current_branch" != "master" ]; then
        # Try to get the remote tracking branch
        remote_tracking=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
        
        if [ -n "$remote_tracking" ]; then
            echo -e "  ${YELLOW}âš  You're currently on branch: ${current_branch} (tracking ${remote_tracking})${RESET}" >&2
            echo -e "  ${CYAN}Base new branch off of:${RESET}" >&2
            echo -e "    ${DIM}1) Current branch (${remote_tracking})${RESET}" >&2
            echo -e "    ${DIM}2) origin/main${RESET}" >&2
            shell_read_prompt "  > " base_choice "-k 1"
            echo "" >&2
            
            if [[ $base_choice =~ ^[1]$ ]]; then
                BASE_BRANCH="$remote_tracking"
                echo -e "  ${GREEN}âœ“${RESET} Will branch from: ${remote_tracking}" >&2
            else
                echo -e "  ${GREEN}âœ“${RESET} Will branch from: origin/main" >&2
            fi
        else
            echo -e "  ${YELLOW}âš  You're currently on branch: ${current_branch} (no remote tracking)${RESET}" >&2
            echo -e "  ${CYAN}Base new branch off of:${RESET}" >&2
            echo -e "    ${DIM}1) Current branch (${current_branch})${RESET}" >&2
            echo -e "    ${DIM}2) origin/main${RESET}" >&2
            shell_read_prompt "  > " base_choice "-k 1"
            echo "" >&2
            
            if [[ $base_choice =~ ^[1]$ ]]; then
                BASE_BRANCH="$current_branch"
                echo -e "  ${GREEN}âœ“${RESET} Will branch from: ${current_branch}" >&2
            else
                echo -e "  ${GREEN}âœ“${RESET} Will branch from: origin/main" >&2
            fi
        fi
        echo "" >&2
    fi

    branch_name="$TICKET_KEY"
    if [ -n "$summary" ]; then
        commit_message="$TICKET_KEY: $summary"
    else
        commit_message="$TICKET_KEY"
    fi

    # Check if branch already exists
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        echo -e "  ${YELLOW}âš  Branch ${branch_name} already exists${RESET}" >&2
        echo -e "  ${DIM}Switching to existing branch...${RESET}" >&2
        
        if [ "$DRY_RUN" = true ]; then
            echo -e "  ${DIM}[DRY RUN] Would run: git checkout ${branch_name}${RESET}" >&2
        else
            # Checkout existing branch - staged changes will come along automatically
            echo -e "  ${DIM}$ git checkout ${branch_name}${RESET}" >&2
            if ! git checkout "$branch_name" 2>&1 | while read -r line; do echo -e "    ${DIM}${line}${RESET}" >&2; done; then
                echo -e "  ${RED}âœ— Failed to checkout branch${RESET}" >&2
                exit 1
            fi
        fi
    else
        echo -e "  ${DIM}Creating branch: ${branch_name} from ${BASE_BRANCH}${RESET}" >&2
        
        if [ "$DRY_RUN" = true ]; then
            echo -e "  ${DIM}[DRY RUN] Would run: git fetch origin${RESET}" >&2
            echo -e "  ${DIM}[DRY RUN] Would run: git checkout -b ${branch_name} ${BASE_BRANCH}${RESET}" >&2
        else
            # Fetch if base is a remote branch
            if [[ "$BASE_BRANCH" =~ ^origin/ ]]; then
                remote_branch="${BASE_BRANCH#origin/}"
                echo -e "  ${DIM}$ git fetch origin ${remote_branch}${RESET}" >&2
                git fetch origin "$remote_branch" 2>&1 | while read -r line; do echo -e "    ${DIM}${line}${RESET}" >&2; done
            fi
            
            # Create branch from base - staged changes will come along automatically
            echo -e "  ${DIM}$ git checkout -b ${branch_name} ${BASE_BRANCH}${RESET}" >&2
            if ! git checkout -b "$branch_name" "$BASE_BRANCH" 2>&1 | while read -r line; do echo -e "    ${DIM}${line}${RESET}" >&2; done; then
                echo -e "  ${RED}âœ— Failed to create branch${RESET}" >&2
                exit 1
            fi
        fi
    fi

    echo -e "  ${GREEN}âœ“${RESET} Branch: ${branch_name}" >&2

    # Verify we're actually on the new branch
    if [ "$DRY_RUN" != true ]; then
        current_branch_check=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ "$current_branch_check" != "$branch_name" ]; then
            echo -e "  ${RED}âœ— Branch verification failed: expected ${branch_name}, but on ${current_branch_check}${RESET}" >&2
            exit 1
        fi
        
        # Verify we have staged changes to commit
        staged_files_check=$(git diff --cached --name-only)
        if [ -z "$staged_files_check" ]; then
            echo -e "  ${RED}âœ— No staged changes found after branch creation${RESET}" >&2
            echo -e "  ${DIM}This might indicate an issue with git stash pop${RESET}" >&2
            exit 1
        fi
    fi

    echo "" >&2
fi  # End of branch creation (SKIP_TO_COMMIT_LOOP check)

# Prompt for first commit message
if [ "${SKIP_TO_COMMIT_LOOP:-false}" != true ]; then
    # Set commit message for new workflow
    commit_message="$TICKET_KEY"
    if [ -n "$summary" ]; then
        commit_message="$TICKET_KEY: $summary"
    fi
    
    echo -e "  ${CYAN}Commit message:${RESET}" >&2
    echo -e "  ${DIM}Default: \"${commit_message}\"${RESET}" >&2
    echo -e "  ${DIM}(Press Enter to use default, or type custom message)${RESET}" >&2
    shell_read_prompt "  > " user_message

    if [ -z "$user_message" ]; then
        current_commit_message="$commit_message"  # Use ticket summary
    else
        # Auto-prefix with ticket key if not present
        if [[ ! "$user_message" =~ ^${TICKET_KEY}: ]]; then
            current_commit_message="$TICKET_KEY: $user_message"
        else
            current_commit_message="$user_message"
        fi
    fi

    echo "" >&2
else
    # Resuming - check if there are staged changes for a first commit
    staged_files_check=$(git diff --cached --name-only)
    if [ -z "$staged_files_check" ]; then
        echo -e "  ${CYAN}No staged changes. Stage files and make commits, or press Enter to proceed to publish.${RESET}" >&2
        SKIP_COMMIT_LOOP=true
        extra_commits_made=false
    else
        # When resuming with commits, we need to re-run prepush
        extra_commits_made=true
        # Has staged changes, prompt for commit message
        commit_message="$TICKET_KEY"
        if [ -n "$summary" ]; then
            commit_message="$TICKET_KEY: $summary"
        fi
        
        echo -e "  ${CYAN}Commit message for staged changes:${RESET}" >&2
        echo -e "  ${DIM}Default: \"${commit_message}\"${RESET}" >&2
        echo -e "  ${DIM}(Press Enter to use default, or type custom message)${RESET}" >&2
        shell_read_prompt "  > " user_message

        if [ -z "$user_message" ]; then
            current_commit_message="$commit_message"
        else
            if [[ ! "$user_message" =~ ^${TICKET_KEY}: ]]; then
                current_commit_message="$TICKET_KEY: $user_message"
            else
                current_commit_message="$user_message"
            fi
        fi

        echo "" >&2
    fi
fi

# Commit loop - support multiple commits interactively
if [ "${SKIP_COMMIT_LOOP:-false}" != true ]; then
    commit_count=0
    extra_commits_made=false

    while true; do
    commit_count=$((commit_count + 1))
    
    # Show what we're about to commit
    if [ $commit_count -eq 1 ]; then
        echo -e "  ${DIM}Committing with message: ${current_commit_message}${RESET}" >&2
    else
        echo -e "  ${DIM}Commit #${commit_count}: ${current_commit_message}${RESET}" >&2
    fi
    
    if [ "$DRY_RUN" = true ]; then
        echo -e "  ${DIM}[DRY RUN] Would run: git commit -m \"${current_commit_message}\"${RESET}" >&2
    else
        # Get current commit hash before attempting commit
        before_commit=$(git rev-parse HEAD 2>/dev/null)
        
        echo -e "  ${DIM}$ git commit -m \"${current_commit_message}\"${RESET}" >&2
        if ! git commit -m "$current_commit_message" 2>&1 | while read -r line; do echo -e "    ${DIM}${line}${RESET}" >&2; done; then
            echo -e "  ${RED}âœ— Commit failed${RESET}" >&2
            exit 1
        fi
        
        # Verify a commit was actually created
        after_commit=$(git rev-parse HEAD 2>/dev/null)
        if [ "$before_commit" = "$after_commit" ]; then
            echo -e "  ${RED}âœ— No commit was created${RESET}" >&2
            echo -e "  ${YELLOW}âš  This may be due to pre-commit hooks unstaging your changes${RESET}" >&2
            echo -e "  ${DIM}Check: git status${RESET}" >&2
            exit 1
        fi
    fi
    
    echo -e "  ${GREEN}âœ“${RESET} Committed (#${commit_count})" >&2
    
    # Track if we made extra commits beyond the first
    if [ $commit_count -gt 1 ]; then
        extra_commits_made=true
    fi
    
    # Ask if user wants to make another commit
    echo "" >&2
    echo -e "  ${CYAN}Make another commit?${RESET} ${DIM}(y/n)${RESET}" >&2
    shell_read_prompt "  > " make_another "-k 1"
    echo "" >&2
    
    if [[ ! $make_another =~ ^[Yy]$ ]]; then
        break
    fi
    
    echo "" >&2
    echo -e "  ${CYAN}Stage your changes, then press Enter to continue${RESET}" >&2
    echo -e "  ${DIM}(In another terminal: git add <files>)${RESET}" >&2
    shell_read_prompt "  > Press Enter when ready..." dummy
    echo "" >&2
    
    # Check for newly staged changes
    new_staged_files=$(git diff --cached --name-only)
    new_staged_count=$(echo "$new_staged_files" | grep -c . || true)
    
    if [ "$new_staged_count" -eq 0 ]; then
        echo -e "  ${YELLOW}âš  No new staged changes, skipping commit${RESET}" >&2
        break
    fi
    
    echo -e "  ${GREEN}âœ“${RESET} ${new_staged_count} file(s) staged:" >&2
    echo "$new_staged_files" | head -5 | while read -r file; do
        echo -e "    ${DIM}${file}${RESET}" >&2
    done
    if [ "$new_staged_count" -gt 5 ]; then
        echo -e "    ${DIM}... and $((new_staged_count - 5)) more${RESET}" >&2
    fi
    echo "" >&2
    
    # Get commit message for this commit
    echo -e "  ${CYAN}Enter commit message:${RESET}" >&2
    echo -e "  ${DIM}(Leave empty to use: ${TICKET_KEY}: <message>)${RESET}" >&2
    shell_read_prompt "  > " user_message
    
    if [ -z "$user_message" ]; then
        # Ask for short description
        echo -e "  ${CYAN}Short description:${RESET}" >&2
        shell_read_prompt "  > " short_desc
        if [ -n "$short_desc" ]; then
            current_commit_message="$TICKET_KEY: $short_desc"
        else
            current_commit_message="$TICKET_KEY: additional changes"
        fi
    else
        # If message doesn't start with ticket key, prepend it
        if [[ ! "$user_message" =~ ^${TICKET_KEY}: ]]; then
            current_commit_message="$TICKET_KEY: $user_message"
        else
            current_commit_message="$user_message"
        fi
    fi
    
    echo "" >&2
    done
else
    # If we skipped commit loop entirely (not resuming), no extra commits were made
    extra_commits_made=false
fi  # End of commit loop

echo "" >&2

# Step 3.5: Run pre-push checks again before publishing
# This ensures any additional commits made in the loop are validated
# Only run if extra commits were added after the initial validation
if [ "$DRY_RUN" != true ] && [ "${extra_commits_made:-false}" = true ]; then
    repo_root=$(git rev-parse --show-toplevel)
    
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“${RESET}" >&2
    echo -e "${CYAN}â”ƒ${RESET} ${BLUE}Pre-publish validation:${RESET} Running checks                  ${CYAN}â”ƒ${RESET}" >&2
    echo -e "${CYAN}â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›${RESET}" >&2
    echo "" >&2
    
    if ! run_prepush_checks "$repo_root"; then
        echo -e "  ${RED}âœ— Pre-push checks failed${RESET}" >&2
        echo -e "  ${YELLOW}âš  Fix the issues and run: oneshot${RESET}" >&2
        echo -e "  ${DIM}(The script will resume from this point)${RESET}" >&2
        exit 1
    fi
elif [ "$DRY_RUN" != true ]; then
    echo -e "  ${DIM}Skipping pre-push checks (no additional commits since last validation)${RESET}" >&2
    echo "" >&2
fi

echo "" >&2

# Step 4: Create MR
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“${RESET}" >&2
echo -e "${CYAN}â”ƒ${RESET} ${BLUE}Step 4/4:${RESET} Creating Merge Request                        ${CYAN}â”ƒ${RESET}" >&2
echo -e "${CYAN}â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›${RESET}" >&2

# Determine target branch for MR (strip origin/ prefix if present)
target_branch="${BASE_BRANCH#origin/}"

if [ "$DRY_RUN" = true ]; then
    echo -e "  ${DIM}[DRY RUN] Would run: SKIP_PRE_PUSH_CHECKS=true publish-changes --branch ${branch_name} --target ${target_branch} ${TICKET_KEY}${RESET}" >&2
    if [ -n "$SLACK_URL" ]; then
        echo -e "  ${DIM}[DRY RUN] Would post MR link to Slack thread${RESET}" >&2
    fi
    echo "" >&2
    echo -e "${GREEN}=== Dry run complete ===${RESET}" >&2
else
    # Run publish-changes and capture the MR URL from stdout
    # Skip pre-push checks since we already ran them earlier
    mr_url=$(SKIP_PRE_PUSH_CHECKS=true "$SCRIPT_DIR/publish-changes" --branch "$branch_name" --target "$target_branch" --output-url --no-draft-prompt "$TICKET_KEY")
    
    # Post MR link to Slack if we have a thread
    if [ -n "$SLACK_URL" ] && [ -n "$mr_url" ]; then
        echo -e "  ${DIM}Posting MR link to Slack thread...${RESET}" >&2
        if post_to_slack "$SLACK_CHANNEL" "$SLACK_THREAD_TS" "mr" "$mr_url" "$commit_message"; then
            echo -e "  ${GREEN}âœ“${RESET} Posted MR link to Slack" >&2
        fi
    fi
    
    # Clear saved state on successful completion
    clear_state
    
    echo "" >&2
    echo -e "${GREEN}=== Done ===${RESET}" >&2
fi
